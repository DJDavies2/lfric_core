!-----------------------------------------------------------------------------
! (c) Crown copyright 2021 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------

!>@brief Base algorithm that contains the various mappings used in the
!>       physics-dynamics multires_coupling miniapp
module multires_coupling_mappings_alg_mod

  use constants_mod,                  only : i_def, r_def
  use mesh_collection_mod,            only : mesh_collection
  use mesh_mod,                       only : mesh_type
  use fem_constants_mod,              only : get_rmultiplicity
  use field_mod,                      only : field_type
  use fs_continuity_mod,              only : W2

  implicit none

  private

  public :: map_w2_vectors_alg, map_scalars_alg

contains

  !> @details An algorithm for mapping W2 vector fields. Note this is
  !> a temporary subroutine which is a placeholder until the W2 mappings
  !> are on trunk
  !> @param[in] source_field  Source W2 field
  !> @param[in,out] target_field  Target W2 field
  subroutine map_w2_vectors_alg( source_field, target_field )

    use prolong_w2_kernel_mod,         only: prolong_w2_kernel_type
    use restrict_w2_kernel_mod,        only: restrict_w2_kernel_type
    use weights_prolong_w2_kernel_mod, only: weights_prolong_w2_kernel_type

    implicit none

    type(field_type),    intent(in)    :: source_field
    type(field_type),    intent(inout) :: target_field

    type(field_type)          :: weights
    type(field_type), pointer :: rmultiplicity_w2 => null()
    type(mesh_type),  pointer :: source_mesh => null()
    type(mesh_type),  pointer :: target_mesh => null()
    integer(kind=i_def)       :: source_mesh_id
    integer(kind=i_def)       :: target_mesh_id
    integer(kind=i_def)       :: source_ncells
    integer(kind=i_def)       :: target_ncells


    ! Get source and target mesh id's and meshes
    source_mesh_id = source_field%get_mesh_id()
    target_mesh_id = target_field%get_mesh_id()
    source_mesh => mesh_collection%get_mesh(source_mesh_id)
    target_mesh => mesh_collection%get_mesh(target_mesh_id)

    ! Figure out which of the meshes has fewer cells
    source_ncells = source_mesh%get_ncells()
    target_ncells = target_mesh%get_ncells()

    ! Map W2 vector field from source to target
    if (source_ncells > target_ncells) then
      rmultiplicity_w2 => get_rmultiplicity(W2, source_field%get_mesh_id())
      call invoke( setval_c(target_field, 0.0_r_def),                  &
                   restrict_w2_kernel_type(target_field, source_field, &
                                           rmultiplicity_w2)           )
      nullify(rmultiplicity_w2)
    else if (source_ncells < target_ncells) then
      ! Normally we will pre-compute the weights in runtime_constants
      ! We do this here for now but it should be moved out in #2600
      call weights%initialise( vector_space = target_field%get_function_space() )
      call invoke( weights_prolong_w2_kernel_type(weights, source_field) )
      ! Prolong kernel increments target_field, so need to set it to be 0 first
      call invoke( setval_c(target_field, 0.0_r_def), &
                   prolong_w2_kernel_type(target_field, source_field, weights) )
      call weights%field_final()
    else
      call invoke( setval_X(target_field, source_field) )
    end if

  end subroutine map_w2_vectors_alg

  !> @details An algorithm for mapping scalar fields
  !> @param[in] source_field  Source field
  !> @param[in,out] target_field Target field
  subroutine map_scalars_alg( source_field, target_field )

    use prolong_kernel_mod,  only: prolong_kernel_type
    use restrict_kernel_mod, only: restrict_kernel_type

    implicit none

    type(field_type),    intent(in)    :: source_field
    type(field_type),    intent(inout) :: target_field

    type(mesh_type), pointer  :: source_mesh => null()
    type(mesh_type), pointer  :: target_mesh => null()
    integer(kind=i_def)       :: source_mesh_id
    integer(kind=i_def)       :: target_mesh_id
    integer(kind=i_def)       :: source_ncells
    integer(kind=i_def)       :: target_ncells


    ! Get source and target mesh id's and meshes
    source_mesh_id = source_field%get_mesh_id()
    target_mesh_id = target_field%get_mesh_id()
    source_mesh => mesh_collection%get_mesh(source_mesh_id)
    target_mesh => mesh_collection%get_mesh(target_mesh_id)

    ! Figure out which of the meshes has fewer cells
    source_ncells = source_mesh%get_ncells()
    target_ncells = target_mesh%get_ncells()

    ! Map scalar field from source to target
    if (source_ncells > target_ncells) then
      call invoke( setval_c(target_field, 0.0_r_def), &
                   restrict_kernel_type(target_field, source_field) )
    else if (source_ncells < target_ncells) then
      call invoke( setval_c(target_field, 0.0_r_def ), &
                   prolong_kernel_type(target_field, source_field) )
    else
      call invoke( setval_X(target_field, source_field) )
    end if

  end subroutine map_scalars_alg

end module multires_coupling_mappings_alg_mod
